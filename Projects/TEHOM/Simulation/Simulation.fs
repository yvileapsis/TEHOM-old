namespace Tehom
open System

(* 
    To tl;dr the point of the project:
    Create a horror text game with a systemic support for body horror to then infuse it with text generation.

    Main goals for the foreseeable future:
    * Add good way of mass-loading entities from some form of config file, currently thinking yaml
    * Add some rudimentary display of context around player entity
    * Add some form of text input that gets processed as actions, rudimentary string comparison would do
    * Make it possible to move player entity from room 1 to room 2

*)

module Screens =

    // Main screens of the game, put here temporarily.
    type Screens =
        | Title
        | SaveLoad
        | Exploration
        | Combat

module GUI =

    // Rough idea for GUI, main elements are input box and scene (current block of text shown)
    type GUI =
        | InputBox
        | Scene
        | Stats
        | OtherElements

module Entity =

    // The only way I can think of tying the entities together without fully including them.
    type EntityID =
        | ID of string
        | GUID of Guid

module Ability =

    // Limits what sort of actions are allowed for each level, i.e. rudimentary brain will disallow talking even with a functioning mouth
    // TODO: come up with better names
    // Main point of thinking is to distinguish 'dead' entities from 'alive', as well as animalistic entities,
    // from ones of higher reasoning and ones of beyond-human reasoning capabilities
    // 'alive' entity always has at least one free functioning task-processing limb, be it brain, processor or whatever else
    type ThinkingLevel =
        | Rudimentary
        | Animalistic
        | Human
        | Beyond

    // TODO: come up with what metric should be those based on
    type SenseType =
        | See of int
        | Hear of int
        | Smell of int
        | Feel of int
        | TelepathicallyFeel of int
        | AllKnowing

    type LocomotionType =
        | Walking
        | Climbing
        | Flying
        | Teleporting

    type GrabType =
        | Grip of int
        | Telekenesis of int

    // List of abilities 'alive' entities can have.
    // For composed entities those should be generated based on their structure and are used to filter for actions
    // the combined entity can do.
    type Ability =
        | CanThink of ThinkingLevel
        | CanSense of SenseType
        | CanGrab of GrabType
        | CanMove of LocomotionType
        | CanTalk
        | IsWeapon

module Trait =
    open Entity

    // Some string describing the object, whether defined as is, or to be generated on demand based on entity context.
    type Description =
        | String of string
        | Autogenerated
        | Inapplicable

    // Combination of object's player-seen name and description.
    type DescriptionTrait = {
        ObjectName: Description
        Description: Description
    }

    // Come up how to unite this with contains as only something that has volume can contain things.
    type Volume =
        | SumOfContained
        | Volume of int64
        | Infinite
        | Inapplicable

    // Any physical object is supposed to have both internal and external volume,
    // to allow for objects that are bigger on the inside i.e.
    type VolumeTrait = {
        Internal: Volume
        External: Volume
    }

    // Could be useful for physical objects to have mass.
    type MassTrait = {
        Mass: int
    }

    type HealthTrait = {
        Health: int
        MaxHealth: int
        Regeneration: int
    }

    open Ability

    // Trait that lists all abilities entity has
    type AbilitiesTrait = {
        List: Ability list
    }

    // Trait that lists other entities parent entity is composed of.
    // It is not necessarily physical, as player party consists of every member of the party.
    // Point of this list is so that we can get slices of this composition based on children traits,
    // i.e. if we apply filter of HasAbility CanMove _ we can get creature's entire locomotion system.
    type CompositionTrait = {
        Objects: EntityID list

        // So at to define ability of parent entity to control its child entities, 
        // I want to define cohesion of the entity agglomeration
        // Low cohesion -> actions are less of orders and more of suggestions
        // i.e. low cohesion party of NPCs will disobey player character
        Cohesion: int
    }

    // Signifies physical attachment, i.e. finger is attached to palm, door is attached to wall.
    // Trait that determines what other entities this entity is attached to.
    // The main issue is that these relations go both ways and can be influenced from either side, 
    // i.e. to use the example from 'Attached': finger can be separated from the hand by a sword,
    // hand can be separated from the finger by a sword, either action result is supposed to be the same.

    type Attached =
        | Strongly
        | WithForce of int
        | Weakly


    // List of traits entities can have, with description being common to most entities.
    // I feel like I am thinking about this in too object-oriented ECS sort of a way.
    // All of those are supposed to be assigned when entity is made.
    // Entity can not have more than one of any type of a trait
    type Trait = 
        | HasDescription of DescriptionTrait
        | HasVolume of VolumeTrait
        | HasMass of MassTrait
        | HasHealth of HealthTrait
        | HasAbilities of AbilitiesTrait
        | HasEffect
        | ComposedOf of CompositionTrait
    // Not used as every trait is its own map in the model.

module Model =
    open Entity
    open Trait

    type Model = {
        // not sure I even need this
        Entities: EntityID list

        ComposedOf: Map<EntityID, CompositionTrait>
        AttachedTo: List<Set<EntityID> * Attached>

        Description: Map<EntityID, DescriptionTrait>
        Volume: Map<EntityID, VolumeTrait>
        Mass: Map<EntityID, MassTrait>
        Health: Map<EntityID, HealthTrait>
        Abilities: Map<EntityID, AbilitiesTrait>

    } with

        static member makeDefault = {
            Entities = []
            ComposedOf = Map.empty
            AttachedTo = List.empty
            Description = Map.empty
            Volume = Map.empty
            Mass = Map.empty
            Health = Map.empty
            Abilities = Map.empty
        }


module Actions =
    // Rough list of actions 'alive' entities should be capable of, each action should require a certain 'Ability'.
    type EntityActions =
        | Look
        | Go

        | Use
        | Equip
        | Unequip
        | Take
        | Drop
        | Give

        | Attack
        | Say

    // Will be reworked, rough draft of actions
    // Somewhere in this module or later there would happen mapping between UI-sent actions and actions player entity does.
    type PlayerActions = 
        | Wait
        | Look
        | Explore
        | Go

        | Self
        | Party

        | Use
        | Equip
        | Unequip
        | Take
        | Drop
        | Give

        | Attack
        | Say

(* 
    Entities can be looked from two angles, structural composition, of what consists of what:
    Table is composed of: table top, 4 table legs.

    And physical composition: 
    * Table top
    * 4 table legs, each attached to table top



    Alive entities are a little more complex.

    What is a cat?

    Alive entities can be also looked at from two angles:

    Physical composition:
    * torso
    * 2 front legs, 2 back legs attached to torso
    * tail attached to torso
    * head attached to torso
        head of course can also be split:
        * skull
        * two eyes attached to skull
        * brain attached to skull
        * skin attached to skull

    Another way to look at the cat is through systems which correspond to its abilities,
    which are retrieved through filtering structural composition for its abilities:
    Cat has:
    * Nervous system -- Filter by CanThink -> brain
    * Sensory system -- Filter by CanSense -> Eyes, nose, ears, skin, etc
    * Locomotion system -- Filter by CanMove -> Legs, paws, tail (?), ???
    * Manipulation system -- Filter by CanGrab -> paws, mouth
    * Talking system -- Filter by CanTalk -> mouth, lungs (?)
    * Attack system - Filter by IsWeapon -> paws, mouth
    New systems can be added later as needed, as it's literally just a filter over the composed entity.



    Horror situations that should be possible in the simulation:
    * Corpses coming alive;
    * Monsters with arrays of limbs;
    * You traversing a large enough creature from the inside a la James Bartley.
    * Parasites traversing your body;
    * Your limbs 'dying' while still attached to your body;
    * Your limb growing multiple eyes that you can see through;
    * Your limb growing multiple eyes that you can not see through;     <- some concept of ownership or control is definitely needed
    * Your limb leaving you to become its own creature that can be either hostile or friendly to player;
    * Various supernatural things like telekenesis or teleportation;
*)